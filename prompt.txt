================================================================================
MOBILE APP AUTHENTICATION WITH FRAPPE - CURRENT IMPLEMENTATION
================================================================================

PROJECT: Ashida Attendance - Employee Self-Service Mobile App
TECH STACK: React Native (Expo) + Frappe/ERPNext Backend
AUTH METHOD: Token-Based Authentication with Device Binding

================================================================================
OVERVIEW - HOW AUTHENTICATION WORKS
================================================================================

We use TOKEN-BASED authentication (NOT session-based) with:
✓ App ID (unique identifier, NOT email)
✓ App Password (separate from Frappe password)
✓ Device Binding (one device per employee)
✓ API Key + Secret for all API calls
✓ Optional password reset on first login

================================================================================
BACKEND CODE SUMMARY (backend_mobile_auth.py)
================================================================================

FUNCTION 1: mobile_app_login()
------------------------------
Purpose: Authenticate user and generate API credentials
Endpoint: /api/method/ashida.ashida_gaxis.api.mobile_auth.mobile_app_login

Parameters:
- usr: App ID (unique identifier from Employee record)
- app_password: App-specific password
- device_id: Unique device identifier (generated by app)
- device_model: Device model name (e.g., "iPhone 14 Pro")
- device_brand: Device manufacturer (e.g., "Apple", "Samsung")

What it does:
1. Finds employee by app_id field
2. Checks if allow_ess is enabled
3. Verifies app_password matches stored password
4. Handles device binding:
   - First login: Registers device_id, device_model, device_brand
   - Subsequent logins: Verifies all device info matches
5. Logs user into Frappe: frappe.local.login_manager.login_as(user_id)
6. Generates/retrieves API key + secret
7. Returns credentials and require_password_reset flag

Returns:
{
  "success": true,
  "data": {
    "employee_id": "HR-EMP-00004",
    "employee_name": "John Doe",
    "user": "john@company.com",
    "api_key": "a1b2c3d4e5f6g7h",
    "api_secret": "x9y8z7w6v5u4t3s",
    "device_id": "ABC123XYZ",
    "app_id": "EMP001",
    "require_password_reset": 0
  }
}


FUNCTION 2: generate_api_credentials()
--------------------------------------
Purpose: Generate or retrieve Frappe API key/secret for user

What it does:
1. Gets User document from Frappe
2. Retrieves existing api_key or generates new one (15-char hash)
3. Always generates fresh api_secret (15-char hash)
4. Saves to User document (api_secret is encrypted)
5. Returns (api_key, api_secret)

Note: This uses Frappe's built-in API authentication system


FUNCTION 3: reset_app_password()
--------------------------------
Purpose: Allow user to reset their app password on first login
Endpoint: /api/method/ashida.ashida_gaxis.api.mobile_auth.reset_app_password
Requires: Authenticated session (called after login)

Parameters:
- new_password: New app password to set

What it does:
1. Gets employee record from authenticated user
2. Updates app_password field
3. Sets require_password_reset = 0
4. Commits changes to database


FUNCTION 4: reset_device_id()
-----------------------------
Purpose: Admin function to reset employee's device binding
Endpoint: /api/method/ashida.ashida_gaxis.api.mobile_auth.reset_device_id
Requires: Employee write permission (Admin only)

Parameters:
- employee_id: Employee ID to reset

What it does:
1. Clears device_id, device_model, device_brand, device_registered_on
2. Allows employee to login from a new device


FUNCTION 5: change_app_password()
---------------------------------
Purpose: Allow user to change their app password
Endpoint: /api/method/ashida.ashida_gaxis.api.mobile_auth.change_app_password
Requires: Authenticated session

Parameters:
- old_app_password: Current app password
- new_app_password: New app password

What it does:
1. Verifies current password matches
2. Updates to new password
3. Commits changes to database

================================================================================
EMPLOYEE DOCTYPE CUSTOM FIELDS (REQUIRED)
================================================================================

These custom fields must exist in Employee doctype:

1. app_id (Data)
   - Label: "App ID"
   - Unique identifier for mobile app login
   - NOT the email address
   - Example: "EMP001", "JD123"

2. app_password (Password)
   - Label: "App Password"
   - Separate password for mobile app
   - NOT the Frappe login password
   - Stored encrypted using get_password() method

3. allow_ess (Check)
   - Label: "Allow Employee Self Service"
   - Must be checked (1) for mobile app access
   - When unchecked, user cannot login

4. device_id (Data)
   - Label: "Device ID"
   - Unique device identifier (UUID from app)
   - Auto-captured on first login
   - Read-only, set by backend

5. device_model (Data)
   - Label: "Device Model"
   - Device model name (e.g., "iPhone 14 Pro")
   - Auto-captured on first login
   - Read-only, set by backend

6. device_brand (Data)
   - Label: "Device Brand"
   - Device manufacturer (e.g., "Apple", "Samsung")
   - Auto-captured on first login
   - Read-only, set by backend

7. device_registered_on (Datetime)
   - Label: "Device Registered On"
   - Timestamp of first device registration
   - Read-only, set by backend

8. require_password_reset (Check)
   - Label: "Require Password Reset"
   - When checked, user must reset password on login
   - App shows ResetPasswordScreen
   - Auto-cleared after successful reset

9. user_id (Link - User)
   - Standard field linking to Frappe User
   - Required for authentication

================================================================================
MOBILE APP LOGIN FLOW
================================================================================

STEP 1: User Opens App
-----------------------
App checks SecureStore for:
- frappe_api_key
- frappe_api_secret
- frappe_user data

If found: Validate credentials and check allow_ess
If not found: Show LoginScreen


STEP 2: User Enters Credentials
--------------------------------
LoginScreen shows:
- Workspace URL (only if not set)
- App ID field
- App Password field

User enters:
- App ID: "EMP001"
- App Password: "MyAppPass123"


STEP 3: App Calls Backend
--------------------------
POST /api/method/ashida.ashida_gaxis.api.mobile_auth.mobile_app_login

Body:
{
  "usr": "EMP001",
  "app_password": "MyAppPass123",
  "device_id": "550e8400-e29b-41d4-a716-446655440000",
  "device_model": "iPhone 14 Pro",
  "device_brand": "Apple"
}


STEP 4: Backend Validates
--------------------------
✓ Employee exists with app_id = "EMP001"
✓ allow_ess = 1
✓ app_password matches
✓ Device binding check:
  - First login: Save device info
  - Subsequent: Verify device info matches


STEP 5: Backend Returns Credentials
------------------------------------
{
  "success": true,
  "data": {
    "employee_id": "HR-EMP-00004",
    "employee_name": "John Doe",
    "user": "john@company.com",
    "api_key": "a1b2c3d4e5f6g7h",
    "api_secret": "x9y8z7w6v5u4t3s",
    "device_id": "550e8400-e29b-41d4-a716-446655440000",
    "app_id": "EMP001",
    "require_password_reset": 1  ← User must reset password
  }
}


STEP 6: App Stores Credentials
-------------------------------
SecureStore.setItem("frappe_api_key", api_key)
SecureStore.setItem("frappe_api_secret", api_secret)
SecureStore.setItem("frappe_user", user_data)
SecureStore.setItem("frappe_site_url", site_url)


STEP 7: Check Password Reset
-----------------------------
If require_password_reset = 1:
  → Navigate to ResetPasswordScreen
  → User sets new password
  → Call reset_app_password()
  → After success, navigate to main app

If require_password_reset = 0:
  → Navigate directly to main app (HomeScreen)

================================================================================
API CALLS AFTER LOGIN
================================================================================

Every API call includes:
Header: Authorization: token {api_key}:{api_secret}

Example: Get Employee Checkin records
--------------------------------------
GET /api/resource/Employee Checkin
Headers:
  Authorization: token a1b2c3d4e5f6g7h:x9y8z7w6v5u4t3s
  Content-Type: application/json

Frappe automatically:
1. Validates token
2. Identifies user
3. Sets user context
4. Checks permissions
5. Returns data or 401 Unauthorized


Example: Create Employee Checkin
---------------------------------
POST /api/resource/Employee Checkin
Headers:
  Authorization: token a1b2c3d4e5f6g7h:x9y8z7w6v5u4t3s
  Content-Type: application/json

Body:
{
  "employee": "HR-EMP-00004",
  "log_type": "IN",
  "time": "2025-11-20 09:00:00",
  "device_id": "19.0671, 72.8953 | Chembur, Mumbai, India"
}

Note: device_id field now stores GPS location for attendance tracking

================================================================================
SESSION VALIDATION ON APP STARTUP
================================================================================

When app starts:
1. Retrieve API credentials from SecureStore
2. Call /api/method/frappe.auth.get_logged_user
   - Header: Authorization: token {api_key}:{api_secret}
3. Check response:
   - Success: Get employee record and verify allow_ess = 1
   - Failure: Clear credentials and show LoginScreen
4. If allow_ess = 0:
   - Clear credentials
   - Show "ESS access disabled" message
   - Navigate to LoginScreen

================================================================================
DEVICE BINDING FLOW
================================================================================

SCENARIO 1: First Login (New Device)
-------------------------------------
1. User logs in with App ID + App Password
2. Backend checks: device_id field is empty
3. Backend saves:
   - device_id
   - device_model
   - device_brand
   - device_registered_on (current timestamp)
4. Login succeeds
5. User can now only login from this device


SCENARIO 2: Subsequent Login (Same Device)
-------------------------------------------
1. User logs in with same device
2. Backend checks: device_id, device_model, device_brand match
3. All match → Login succeeds


SCENARIO 3: Login from Different Device
----------------------------------------
1. User tries to login from new device
2. Backend checks: device info doesn't match
3. Login fails with error:
   "Access denied. This account is registered to a different device.
    Please contact HR to reset device access."
4. Admin must call reset_device_id() to allow new device


SCENARIO 4: Admin Resets Device
--------------------------------
1. Admin calls reset_device_id(employee_id)
2. Backend clears all device fields
3. User can now login from new device
4. New device info will be registered

================================================================================
SECURITY FEATURES
================================================================================

✓ Separate App Password
  - NOT the Frappe password
  - Frappe desk access remains secure
  - Can be changed independently

✓ Device Binding
  - One device per employee
  - Prevents unauthorized device access
  - Admin can reset if needed

✓ Token-Based Authentication
  - API secret stored encrypted in database
  - Tokens stored in SecureStore on device
  - No session expiry issues

✓ Permission System
  - All Frappe role-based permissions enforced
  - User context set for every API call
  - Can only access allowed data

✓ ESS Toggle
  - Admin can disable mobile access anytime
  - App validates on startup
  - Automatic logout if disabled

✓ Password Reset Flow
  - Force password change on first login
  - User sets own secure password
  - Flag automatically cleared after reset

✓ GPS Location Tracking
  - Captures location for check-in/check-out
  - Coordinates + address stored in device_id field
  - Format: "19.0671, 72.8953 | Full Address"

================================================================================
KEY DIFFERENCES FROM STANDARD FRAPPE LOGIN
================================================================================

STANDARD FRAPPE LOGIN:
- Uses email + Frappe password
- Creates session cookie
- Session expires after timeout
- Complex cookie management on mobile
- No device binding

OUR CUSTOM LOGIN:
- Uses App ID + App Password
- Generates API key + secret
- Tokens never expire
- Simple token header on mobile
- Device binding enforced
- Password reset flow
- GPS location tracking

================================================================================
COMMON OPERATIONS
================================================================================

LOGIN:
POST /api/method/ashida.ashida_gaxis.api.mobile_auth.mobile_app_login
Body: { usr, app_password, device_id, device_model, device_brand }

RESET PASSWORD (First Login):
POST /api/method/ashida.ashida_gaxis.api.mobile_auth.reset_app_password
Body: { new_password }
Requires: Authenticated session

CHANGE PASSWORD:
POST /api/method/ashida.ashida_gaxis.api.mobile_auth.change_app_password
Body: { old_app_password, new_app_password }
Requires: Authenticated session

RESET DEVICE (Admin):
POST /api/method/ashida.ashida_gaxis.api.mobile_auth.reset_device_id
Body: { employee_id }
Requires: Employee write permission

VALIDATE SESSION:
GET /api/method/frappe.auth.get_logged_user
Header: Authorization: token {api_key}:{api_secret}

GET DATA:
GET /api/resource/{DocType}
Header: Authorization: token {api_key}:{api_secret}

CREATE DATA:
POST /api/resource/{DocType}
Header: Authorization: token {api_key}:{api_secret}
Body: { field1, field2, ... }

================================================================================
ERROR HANDLING
================================================================================

Common Errors:

1. "Invalid App ID"
   - app_id not found in Employee doctype
   - Check app_id field value

2. "Employee Self Service is not enabled for this account"
   - allow_ess is unchecked
   - Admin must enable ESS

3. "Invalid app password"
   - app_password doesn't match
   - Check password in Employee record

4. "App password not set"
   - app_password field is empty
   - Admin must set initial password

5. "Access denied. This account is registered to a different device"
   - device_id/model/brand mismatch
   - Admin must reset device binding

6. 401 Unauthorized (API calls)
   - Invalid or expired API credentials
   - Re-login required

================================================================================
SUMMARY
================================================================================

The authentication system uses:

1. Custom login endpoint (mobile_app_login)
2. App ID + App Password (not email/Frappe password)
3. Device binding (device_id + model + brand)
4. Frappe API key/secret generation (token-based auth)
5. Password reset flow (optional first login)
6. ESS toggle (allow_ess field)
7. GPS location tracking for attendance

This provides:
✓ Enhanced security (separate credentials)
✓ Device control (one device per user)
✓ Better UX (no session expiry)
✓ Full permission system (Frappe roles)
✓ Admin control (ESS toggle, device reset)
✓ Location tracking (GPS coordinates + address)

Backend Functions:
- mobile_app_login(): Main authentication
- generate_api_credentials(): Token generation
- reset_app_password(): First login password reset
- change_app_password(): Change password
- reset_device_id(): Admin device reset

All API calls use: Authorization: token {api_key}:{api_secret}

================================================================================
APP RESTART & PASSWORD RESET PERSISTENCE
================================================================================

QUESTION: How does the app redirect to ResetPasswordScreen after being killed?

When app is installed, user logs in successfully, reaches ResetPasswordScreen,
then kills the app and reopens - how does it know to show ResetPasswordScreen?

ANSWER: Session Restoration on App Startup
-------------------------------------------

STEP 1: App Opens (Fresh Start or After Being Killed)
------------------------------------------------------
AuthContext automatically runs restoreSession() on mount:

useEffect(() => {
  restoreSession();
}, []);


STEP 2: restoreSession() Function Flow
---------------------------------------
Located in: app/_contexts/AuthContext.js

1. Check SecureStore for saved credentials:
   - frappe_api_key
   - frappe_api_secret
   - frappe_user (JSON string with user data)
   - frappe_site_url

2. If credentials exist, validate session:
   GET /api/method/frappe.auth.get_logged_user
   Header: Authorization: token {api_key}:{api_secret}

3. Fetch fresh employee data (including require_password_reset):
   GET /api/resource/Employee
   Filter: user_id = current_user_email
   Fields: ['name', 'employee_name', 'user_id', 'allow_ess', 'require_password_reset']

4. Update user state with fresh data:
   const fullUserData = {
     ...userData,
     employee_id: employees[0].name,
     employee_name: employees[0].employee_name,
     require_password_reset: employees[0].require_password_reset  // Fresh from DB!
   };

   setUser(fullUserData);

5. Store updated user data back to SecureStore:
   SecureStore.setItemAsync('frappe_user', JSON.stringify(fullUserData));


STEP 3: Navigation Logic (Reactive)
------------------------------------
Located in: app/(auth)/_layout.js

Navigation automatically responds to user state:

if (!user) {
  // No credentials found or validation failed
  return <LoginScreen />;
}

if (user.require_password_reset === 1) {
  // Password reset required
  return <ResetPasswordScreen />;
}

// All good, show main app
return <MainTabs />;


STEP 4: After Password Reset
-----------------------------
When user successfully resets password:

1. Call: /api/method/ashida.ashida_gaxis.api.mobile_auth.reset_app_password
   Body: { new_password }

2. Backend updates Employee record:
   - app_password = new_password (encrypted)
   - require_password_reset = 0

3. App refetches employee data or updates user state:
   setUser({ ...user, require_password_reset: 0 });

4. Navigation automatically detects change:
   user.require_password_reset === 0 → Navigate to HomeScreen


COMPLETE FLOW DIAGRAM
----------------------

[App Opens]
    ↓
[AuthContext.restoreSession()]
    ↓
[Check SecureStore]
    ↓
Credentials found?
    ↓ NO → [Show LoginScreen]
    ↓ YES
[Validate with Frappe API]
Authorization: token {api_key}:{api_secret}
    ↓
Valid?
    ↓ NO → [Clear credentials, Show LoginScreen]
    ↓ YES
[Fetch Employee Record]
Get: name, employee_name, allow_ess, require_password_reset
    ↓
[Update user state with fresh data]
setUser({ ...data, require_password_reset: value_from_db })
    ↓
[Navigation checks user.require_password_reset]
    ↓
require_password_reset === 1?
    ↓ YES → [Show ResetPasswordScreen]
    ↓ NO
allow_ess === 0?
    ↓ YES → [Logout, Show LoginScreen]
    ↓ NO
[Show HomeScreen - Main App]


WHY IT WORKS AFTER KILLING APP
-------------------------------

Key Point: SecureStore persists across app restarts!

1. SECURESTORE IS PERMANENT STORAGE:
   - NOT cleared when app is killed
   - NOT cleared when app is removed from RAM
   - ONLY cleared when:
     * App is uninstalled
     * User explicitly logs out
     * App code clears it

2. API CREDENTIALS DON'T EXPIRE:
   - Token-based authentication
   - api_key + api_secret never expire
   - Valid until admin regenerates them

3. REQUIRE_PASSWORD_RESET IS FETCHED FRESH:
   - Not just read from SecureStore
   - Fetched from Frappe database every startup
   - Source of truth is always the database
   - Even if app is killed for days, value is current

4. NAVIGATION IS REACTIVE:
   - Responds automatically to user state
   - When user.require_password_reset changes, navigation updates
   - No manual routing needed


EXAMPLE SCENARIO
----------------

Day 1:
------
1. User installs app
2. Enters workspace URL, App ID, App Password
3. Backend validates and returns:
   {
     "api_key": "abc123",
     "api_secret": "xyz789",
     "require_password_reset": 1  ← Password reset required!
   }
4. App stores in SecureStore:
   - frappe_api_key: "abc123"
   - frappe_api_secret: "xyz789"
   - frappe_user: { ..., require_password_reset: 1 }
5. Navigation sees require_password_reset: 1
6. Shows ResetPasswordScreen
7. **USER KILLS APP** (doesn't set password yet)

Day 2:
------
1. User opens app again
2. restoreSession() runs:
   - Finds api_key + api_secret in SecureStore ✓
   - Validates with Frappe API ✓
   - Fetches Employee record from database
   - Gets: require_password_reset: 1 (still not reset!)
3. Updates user state: { ..., require_password_reset: 1 }
4. Navigation checks user.require_password_reset
5. Value is 1 → Shows ResetPasswordScreen again ✓

User sets new password:
-----------------------
1. Calls reset_app_password(new_password)
2. Backend updates database:
   - app_password = new password
   - require_password_reset = 0
3. App updates user state: { ..., require_password_reset: 0 }
4. Navigation sees require_password_reset: 0
5. Shows HomeScreen ✓

Day 3:
------
1. User opens app
2. restoreSession() fetches Employee record
3. Gets: require_password_reset: 0 (already reset)
4. Navigation sees require_password_reset: 0
5. Shows HomeScreen directly ✓


IMPORTANT CODE LOCATIONS
-------------------------

1. Session Restoration:
   File: app/_contexts/AuthContext.js
   Function: restoreSession()
   - Fetches fresh employee data on every app start
   - Updates user state with require_password_reset flag

2. Navigation Logic:
   File: app/(auth)/_layout.js
   - Checks user.require_password_reset
   - Routes to appropriate screen

3. Password Reset:
   File: app/(auth)/ResetPasswordScreen.js
   - Shows password reset form
   - Calls reset_app_password()
   - Updates user state after success

4. SecureStore Usage:
   Files: app/_contexts/AuthContext.js
   Keys stored:
   - frappe_api_key
   - frappe_api_secret
   - frappe_user (includes require_password_reset)
   - frappe_site_url


SUMMARY
-------

The app redirects to ResetPasswordScreen after being killed because:

1. ✓ API credentials are stored in SecureStore (persists across restarts)
2. ✓ require_password_reset flag is stored in Frappe database (source of truth)
3. ✓ restoreSession() fetches fresh data from database on every startup
4. ✓ Navigation is reactive to user.require_password_reset value
5. ✓ Until user actually resets password, flag remains 1 in database

The app doesn't "remember" to show ResetPasswordScreen - it CHECKS the
database on every startup and makes a fresh decision based on current data!

================================================================================
